<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>MODULE 2.1</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: helvetica;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>MODULE 2.1</h1>

<hr/>

<h2>Objectives:</h2>

<h3>Determine the characteristics of polygon, point, and line shapefiles, and rasters as spatial objects in R.</h3>

<hr/>

<hr/>

<h4>STUDENT WORKSHOP: USING R TO MODEL, MANIPULATE, AND MANAGE SPATIAL DATA</h4>

<h4>IALE 2015 World Congress, Portland, OR USA 7 July 2015</h4>

<blockquote>
<p>Karl Jarvis, Northern Arizona University</p>

<p>Whalen Dillon, North Carolina State University</p>

<p>Jill Deines, Michigan State University</p>

<p>Francesco Tonini, North Carolina State University</p>

<p>Thomas Edwards, U.S. Geological Survey and Utah State University</p>
</blockquote>

<h4>MODULE 2.1 CODE BY:</h4>

<blockquote>
<p>Thomas C. Edwards, U.S. Geological Survey and Department of Wildland Resources</p>

<p>Utah State University, Logan UT 84322-5230 USA <a href="mailto:t.edwards@usu.edu">t.edwards@usu.edu</a></p>

<p>(Tested on R versions 3.1.X, 3.2.X)</p>
</blockquote>

<hr/>

<hr/>

<h3>Let&#39;s begin.</h3>

<p>Start by loading some important libraries &hellip;</p>

<pre><code class="r">## some libraries ...
   library(maptools) # fxns: readShapePoly
   library(rgdal)    # fxns: readOGR, spTransform
   library(raster)   # fxns: drawPoly
</code></pre>

<p>&hellip; and set some paths &hellip;</p>

<pre><code class="r">## some initializations ...
   #path.root &lt;- &quot;~/IALE2015_gisRcourse&quot;
   path.dat=&quot;E:/IALE2015_gisRcourse/data&quot;
   #path.root &lt;- &quot;~/words/classes/IALE2015_gisRcourse&quot;
   #path.dat &lt;- paste(path.root, &quot;/data&quot;, sep = &quot;&quot;)
   setwd(path.dat)
</code></pre>

<hr/>

<h3>Examining the Characteristics of Polygon Shapefiles</h3>

<hr/>

<p>Recall from Module 1.1 that two basic options exist for importing shapefile data in to R: <strong>readShapePoly()</strong> (package <strong>maptools</strong>) and <strong>readOGR()</strong> (package <strong>rgdal</strong>).  Both have pros and cons.  Let&#39;&#39;s start with <strong>readShapePoly()</strong> and import a shapefile representing the boundary of the Colorado Plateau region of southwestern North America (COP_boundpoly_aea).  The boundary has an Albers Equal Area (AEA) projection.</p>

<pre><code class="r">#### polygon data
## import polygon shapefile w/out attributes; EXAMPLE Colorado Plateau (CP) boundary in Albers
## shapefiles of polygons are of class =&gt; SpatialPolygonsDataFrame in R
##   fxn readShapePoly
   cp.poly1 &lt;- readShapePoly(&quot;COP_boundpoly_aea&quot;)
   cp.poly1  # examine attributes; NOTE no projection (coord. ref) assignment
</code></pre>

<p>One of the downsides of <strong>readShapePoly()</strong> is that it does not automatically assign a projection (coord. ref.) during import.  Note below that coord. ref. for the object <strong>cp.poly1</strong> is NA even though we know, as stated above, that the projection is in AEA.  While we learned how to assign the projection using the <strong>proj4string =</strong>option of <strong>readShapePoly()</strong>, the <strong>readOGR()</strong> call may be easier to use.</p>

<pre><code>class       : SpatialPolygonsDataFrame 
features    : 1 
extent      : -1540636, -959647.5, 1521625, 2076339  (xmin, xmax, ymin, ymax)
coord. ref. : NA 
variables   : 1
names       : Id 
min values  :  0 
max values  :  0 
</code></pre>

<pre><code class="r">## import polygon shapefile w/out attributes; EXAMPLE Colorado Plateau (CP) boundary in Albers
##   fxn readOGR; # dsn=&quot;.&quot; is cur dir, layer=&quot;shapefile to import&quot;
   cp.poly2 &lt;- readOGR(dsn = &quot;.&quot;, layer = &quot;COP_boundpoly_aea&quot;) 
   cp.poly2  # examine attributes; NOTE has projection (coord.ref)
</code></pre>

<p>In contrast to <strong>readShapePOly()</strong>, <strong>readOGR()</strong> automatically assigns the native projection of the shapefile; see this by looking at the <strong>coord. ref</strong> in cp.poly2 below.</p>

<pre><code>class       : SpatialPolygonsDataFrame 
features    : 1 
extent      : -1540636, -959647.5, 1521625, 2076339  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0 
variables   : 1
names       : Id 
min values  :  0 
max values  :  0 
</code></pre>

<p>You can use the <strong>str()</strong> call to see the characteristics of any spatial data object.</p>

<pre><code class="r">##   examine structure; NOTE characteristic called &quot;slots&quot;
   str(cp.poly2)  # examine structure
</code></pre>

<p>The structure of spatial objects - a class called <strong>SpatialPolygonsDataFrame</strong> - looks different that that of R class <strong>data.frame</strong>.  Principal of these differences is the presence of so-called &ldquo;<em>slots</em>&rdquo;, which are accessed via the symbol <strong>@</strong>.  <strong>@</strong> operates just like the <strong>$</strong>; it, however, is specific to spatial data objects only.  </p>

<p>The first of the slots in the object cp.poly2 is <strong>@data</strong>.  Consider this analogous to the attributes table of a ArcGIS shapefile.  The <strong>@polygons</strong> defines the individual polygons within the spatial object.  In this example, there is only one polygon (note &ldquo;List of 1&rdquo;) - the outline of the Colorado Plateau.  If you had 100 polygons, there would 100 separate polygons and the &ldquo;:List of&rdquo; would indicate 100.  <strong>@plotOrder</strong> is similar to the the ID of ArcGIS, but in my experience a 1:1 matching of the ArcGIS ID and <strong>SpatialPolygonsDataFrame</strong> plot order is not always guaranteed.  Be cautious.  The bounding box of the polygon is defined by <strong>@bbox</strong> while the projection is defined by <strong>@proj4tsring</strong>.  All of these values can be directly accessed.</p>

<pre><code>Formal class &#39;SpatialPolygonsDataFrame&#39; [package &quot;sp&quot;] with 5 slots
  ..@ data       :&#39;data.frame&#39;: 1 obs. of  1 variable:
  .. ..$ Id: int 0
  ..@ polygons   :List of 1
  .. ..$ :Formal class &#39;Polygons&#39; [package &quot;sp&quot;] with 5 slots
  .. .. .. ..@ Polygons :List of 1
  .. .. .. .. ..$ :Formal class &#39;Polygon&#39; [package &quot;sp&quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] -1192875 1794756
  .. .. .. .. .. .. ..@ area   : num 1.81e+11
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:97871, 1:2] -1131348 -1131326 -1131291 -1131265 -1131227 ...
  .. .. .. ..@ plotOrder: int 1
  .. .. .. ..@ labpt    : num [1:2] -1192875 1794756
  .. .. .. ..@ ID       : chr &quot;0&quot;
  .. .. .. ..@ area     : num 1.81e+11
  ..@ plotOrder  : int 1
  ..@ bbox       : num [1:2, 1:2] -1540636 1521625 -959648 2076339
  .. ..- attr(*, &quot;dimnames&quot;)=List of 2
  .. .. ..$ : chr [1:2] &quot;x&quot; &quot;y&quot;
  .. .. ..$ : chr [1:2] &quot;min&quot; &quot;max&quot;
  ..@ proj4string:Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot
  .. .. ..@ projargs: chr &quot;+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0&quot;| __truncated__

</code></pre>

<p>You can access the bounding box of the polygon &hellip;</p>

<pre><code class="r">##   &quot;slots&quot; are where shapefile attributes are carried
##     @ symbol access slots, eg cp.poly@bbox
   cp.poly2@bbox  # returns the bounding box of the polygon
</code></pre>

<pre><code>       min       max
x -1540636 -959647.5
y  1521625 2076338.7
</code></pre>

<p>&hellip; or the projection &hellip;</p>

<pre><code class="r">   cp.poly2@proj4string  # returns the projection (coord. ref)
</code></pre>

<pre><code>CRS arguments:
 +proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m
+no_defs +ellps=GRS80 +towgs84=0,0,0 
</code></pre>

<p>&hellip; or even the geogrpahic center of the polygon.</p>

<pre><code class="r">   coordinates(cp.poly2)  # coordinate centroid of polygon
</code></pre>

<pre><code>      [,1]    [,2]
0 -1192875 1794756
</code></pre>

<p>Next, let&#39;&#39;s examine a slightly more complex shapefile of polygons, the North America states.</p>

<pre><code class="r">## import point shapefile w/attributes; EXAMPLE N American States
## shapefiles of polygons are of class =&gt; SpatialPolygonsDataFrame in R
##   fxn readOGR
   states &lt;- readOGR(dsn = &quot;.&quot;, layer = &quot;na_states_aea&quot;)
   states  # examine
</code></pre>

<p>Unlike the previous <strong>cp.poly2</strong> example from above, we see two variables of names <strong>CODE</strong> and <strong>NAME</strong>.  Also, since we used <strong>readOGR()</strong> to import the shapefile, there is an assigned projection.</p>

<pre><code>class       : SpatialPolygonsDataFrame 
features    : 95 
extent      : -6293578, 3189093, -893447.8, 6198911  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0 
variables   : 2
names       : CODE,           NAME 
min values  :   AK, Aguascalientes 
max values  :   WY,      Zacatecas 
</code></pre>

<p>Although not run here, you could call the <strong>str(states)</strong> to examine the spatial object structure.  Output will voluminous since there 95 separate polygons, but the overall structure will be identical to that we examined for <strong>cp.poly2</strong> above.  Feel free to do it; but if you do, pay special attention to the <strong>@data</strong> at the top.</p>

<p>Next assume you wish to access the two variables in the spatial object, starting with <strong>CODE</strong>.  This can be done simply by calling <strong>states@data$CODE</strong>.  Note, however, that since the <strong>@data</strong> is of class <strong>data.frame</strong>, you can bypass the <strong>@data</strong> and use the <strong>data.frame</strong> link <strong>$</strong> to access variable values.</p>

<pre><code class="r">##   examine structure !!!! WARNING !!!! NOT RUN voluminous output w/str()
   #str(states)  # NOTE there are 95 states and 95 polygons, 1 for each state
##   shapefile data in dataframe &quot;data&quot; with variables &quot;CODE&quot; and &quot;NAME&quot;
   states@data$CODE  # returns state codes; NOTE $ to access specific variables
   #states@data$NAME  # NOT RUN returns state codes; NOTE $ to access specific variables
##   can bypass long call (as below) for class =&gt; dataframe elements
   #states$CODE  # NOT RUN bad habit based on experience; recommend use long call
</code></pre>

<pre><code> [1] CA10 CA06 CA07 CA11 CA01 CA05 CA02 CA04 CA09 CA12 CA03 CA08 MX02 MX03 MX18 MX14 MX01 MX11 MX22 MX13 MX16
[22] MX15 MX09 MX08 MX17 MX31 MX04 MX21 MX23 MX29 MX12 MX20 MX27 MX05 MX26 MX06 MX07 MX25 MX10 MX32 MX24 MX19
[43] MX28 MX30 WA   MT   ME   ND   SD   WY   WI   ID   VT   MN   OR   NH   IA   MA   NE   NY   PA   CT   RI  
[64] NJ   IN   NV   UT   CA   OH   IL   DC   DE   WV   MD   CO   KY   KS   VA   MO   AZ   OK   NC   TN   TX  
[85] NM   AL   MS   GA   SC   AR   LA   FL   MI   HI   AK  
95 Levels: AK AL AR AZ CA CA01 CA02 CA03 CA04 CA05 CA06 CA07 CA08 CA09 CA10 CA11 CA12 CO CT DC DE FL ... WY
</code></pre>

<hr/>

<h3>Examining the Characteristics of Point Shapefiles</h3>

<hr/>

<pre><code class="r">## import point shapefile w/attributes; EXAMPLE cities in the Colorado Plateau
## shapefiles of points are of class =&gt; SpatialPointsDataFrame in R
##   fxn readOGR
   cp.cities &lt;- readOGR(&quot;.&quot;, layer = &quot;COP_Major_Cities_pt&quot;)
   cp.cities  # examine
   #str(cp.cities)  # NOT RUN; NOTE @data attributes
</code></pre>

<p>Note that spatial object class is <strong>SpatialPointsDataFrame</strong>, that there is a valid projection and extent, and that there are 47 variables.  These 47 variables are the attributes of the shapefile.</p>

<pre><code>class       : SpatialPointsDataFrame 
features    : 4 
extent      : -1538914, -1022743, 1591974, 1854957  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0 
variables   : 47
names       : OBJECTID,       NAME, CLASS, ST, STFIPS, PLACEFIP, CAPITAL, AREALAND, AREAWATER, POP_CLASS, POP2000, POP2007, WHITE, BLACK, AMERI_ES, ... 
min values  :      193, Farmington,  City, CO,     08,    25800,      NA,   11.469,     0.000,         6,   12344,   14611, 10987,    54,      121, ... 
max values  :      684, St. George,  City, UT,     49,    65330,      NA,   64.397,     0.471,         6,   49663,   72459, 45823,   316,     6419, ... 
</code></pre>

<pre><code class="r">##   attribute names in point shapefile
   names(cp.cities)  # returns all attribute names in shapefile
   cp.cities$NAME  # returns cities in CP
   cp.cities$POP2000  # returns 2000 population by city in CP
   cp.cities$POP2007  # returns 2007 population by city in CP
   coordinates(cp.cities)  # returns coordinates of cities
</code></pre>

<p>Values of any of the variables can accessed quite easily.  Here we access, in order, the names of the cities, their respective 200 and 2007 population numbers, and their coordinates.</p>

<pre><code># names of cities in CP
[1] St. George     Montrose       Grand Junction Farmington    
Levels: Farmington Grand Junction Montrose St. George
# 2000 population by city in CP
[1] 49663 12344 41986 37844
# 2007 population by city in CP
[1] 72459 14611 47597 41191
# coordinates of cities
     coords.x1 coords.x2
[1,]  -1538914   1704164
[2,]  -1022743   1780215
[3,]  -1073270   1854957
[4,]  -1075272   1591974
</code></pre>

<p>Thinking ahead, once the data ar in your workspace, any of R&#39;&#39;s analytical capabilities can now be applied.</p>

<pre><code class="r">## which cities had a population &gt; 40000 in 2000?
   cp.cities$NAME[cp.cities$POP2000&gt;40000]
</code></pre>

<pre><code>[1] St. George     Grand Junction
Levels: Farmington Grand Junction Montrose St. George
</code></pre>

<hr/>

<h3>Examining the Characteristics of Line Shapefiles</h3>

<hr/>

<p>We&#39;&#39;ve seen polygon and point spatial objects in R, and learned how to view and access their characteristics.  Let&#39;&#39;s now examine line shapefiles, reading in a line shapefile (<strong>cp.hohflow</strong>) of all water in the Colorado Plateau.</p>

<pre><code class="r">## import lines shapefile; EXAMPLE NHD streams and rivers
## shapefiles of lines are of class =&gt; SpatialLinesDataFrame in R
   cp.hohflow &lt;- readOGR(dsn = &quot;.&quot;, layer = &quot;COP_NHD_Flowlines_line&quot;)
   cp.hohflow  # examine
   #str(cp.hohflow)  # NOT RUN; lots of output !!
   names(cp.hohflow)  # all attribute names
</code></pre>

<p>Lines are of class <strong>SpatialLinesDataFrame</strong>.  By now the pattern of characteristics of spatial objects in R should be obvious; a <strong>class</strong>, <strong>extent</strong>, projection <strong>coord. ref.</strong>, <strong>variables</strong>, and other attributes.  </p>

<pre><code>class       : SpatialLinesDataFrame 
features    : 52214 
extent      : -1539836, -960621.6, 1522352, 2075805  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0 
variables   : 19
names       : OBJECTID,     ComID, Permanent_,      FDate, Resolution,  GNIS_ID,     GNIS_Name, LengthKM,      ReachCode, FlowDir, WBAreaComI, WBArea_Per, FType, FCode, Shape_Leng, ... 
min values  :        0,   1253302,   10020280, 1999/06/26,          3, 00000417,   Adobe Creek,    0.001, 14010005000002,       0,          0,         NA,   334, 33400, 0.00000540, ... 
max values  :    40306, 162424417,    9771310, 2010/02/09,          3,   204653, Zenobia Creek,   30.925, 15010010003505,       1,          0,         NA,   558, 55800, 0.31650256, ... 
</code></pre>

<p>Note in the <strong>cp.hohflow</strong> that the <strong>features</strong> object has 52214 values.  This means there are 52214 separate lines in the shapefile, each representing a named water creek, river, or non-point water source.  (As an aside, would lakes and reservoirs be lines or polygons ??)  Assuming you interested only in named &ldquo;rivers,&rdquo; how could access those as a subset of the 52214 possible features?</p>

<p>Any basic R code for subsetting or extracting could be applied to achieve this objective.  The example below is one of many possibilities, and is shown as two separate lines for illustrative purposes even though it could readily be done in a single line.  The first creates an object of all unique names.  You, of course, would have to know which of the <strong>names</strong> in the shapefile represents the actual names of the water lines; here it is <strong>GNIS_Name</strong>.  The second merely grabs those names from set of names that have &ldquo;River&rdquo; attached to them.  Again, there are many, many different ways you could do this.  At the end, you can see there are 48 water lines with &ldquo;River&rdquo; in their name out of 1334 possible names.</p>

<pre><code class="r">## create list of unique names and use to subset rivers
   hohflow.nm &lt;- unique(cp.hohflow$GNIS_Name)  # list of values in column GNIS_Name
   hohflow.rv &lt;- hohflow.nm[grep(&quot;River&quot;, hohflow.nm)]  # select GNIS_Name w/&#39;River&#39; only
   hohflow.rv  # examine
</code></pre>

<pre><code> [1] Colorado River                  Gunnison River                  Cimarron River                 
 [4] North Fork Gunnison River       North Smith Fork Gunnison River Uncompahgre River              
 [7] West Fork Cimarron River        Little Cimarron River           Middle Fork Cimarron River     
[10] East Fork Little Cimarron River Dolores River                   San Miguel River               
[13] Little Dolores River            Green River                     Yampa River                    
[16] White River                     Little Snake River              Duchesne River                 
[19] San Rafael River                Price River                     Strawberry River               
[22] Lake Fork River                 Uinta River                     Whiterocks River               
[25] Yellowstone River               West Fork Whiterocks River      West Fork Duchesne River       
[28] East Fork Duchesne River        West Channel Uinta River        Fremont River                  
[31] Escalante River                 Dirty Devil River               Paria River                    
[34] San Juan River                  Animas River                    Mancos River                   
[37] La Plata River                  Chaco River                     Middle Mancos River            
[40] Los Pinos River                 West Mancos River               South Fork West Mancos River   
[43] Florida River                   East Mancos River               North Fork West Mancos River   
[46] North Fork Virgin River         East Fork Virgin River          Virgin River                   
1334 Levels: Adobe Creek Al Wright Creek Alcove Brook Alder Creek Alfalfa Run Alkali Creek ... Zenobia Creek
</code></pre>

<p>We&#39;&#39;ve now finished examining shapefiles, and move on to examining the characteristics of rasters (grids).</p>

<hr/>

<h3>Examining the Characteristics of Rasters (Grids)</h3>

<hr/>

<p>Start by importing a simple raster of type <strong>ENVI</strong>, as was shown in Module 1.2.  Many of the characteristics we saw in shapefiles are also found in rasters.  It has a class - <strong>RasterLayer</strong> - and if <strong>str()</strong> is applied you will see <em>slots</em> as well.  There are 12 in a basic raster.</p>

<pre><code class="r">## import raster (grid) file; EXAMPLE NDVI values SW USA
   ndvi500m &lt;- raster(&quot;N200530602133CBR_v1.1.dat&quot;, format = &quot;ENVI&quot;)
   ndvi500m  # examine raster attributes; single layer
   #str(ndvi500m)  # NOT RUN; examine structure
</code></pre>

<p>Rasters are all rectangular, so much of the information is related to the number of rows and columns defining the rectangle, which themselves are a function of the raster resolution.  Although not run here, apply <strong>str()</strong> to the raster to see the slots.</p>

<pre><code>class       : RasterLayer 
dimensions  : 4288, 4171, 17885248  (nrow, ncol, ncell)
resolution  : 0.004166667, 0.004166667  (x, y)
extent      : -121.612, -104.2328, 27.83958, 45.70625  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 
data source : E:\IALE2015_gisRcourse\data\N200530602133CBR_v1.1.dat 
names       : N200530602133CBR_v1.1 
values      : -32768, 32767  (min, max)
</code></pre>

<p>Some of the more important characteristics of rasters to be aware of include the dimensions (<strong>dim()</strong>), resolution (<strong>res()</strong>), <strong>extent()</strong>, and, of course, projection (<strong>coord. ref.</strong>).  <strong>values</strong> shows the (min, max) of the named variable(s).  As we will learn later, multiple rasters must be virtually identical prior to performing analyses.</p>

<pre><code class="r">   names(ndvi500m)  # examine raster names
   extent(ndvi500m)  # examine raster extent
   dim(ndvi500m)  # examine raster {X,Y] cell Nos.
   ncell(ndvi500m)  # examine raster No. cells
   res(ndvi500m)  # examine raster resolution
   projection(ndvi500m)  # examine raster projection
   ndvi500m@crs@projargs  # same projection as above; access via slots
</code></pre>

<pre><code># raster variable(s) name(s)
[1] &quot;N200530602133CBR_v1.1&quot;
# raster extent
class       : Extent 
xmin        : -121.612 
xmax        : -104.2328 
ymin        : 27.83958 
ymax        : 45.70625 
# raster {X,Y] cell Nos.
[1] 4288 4171    1
# raster No. cells
[1] 17885248
# raster resolution
[1] 0.004166667 0.004166667
# raster projection
[1] &quot;+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0&quot;
# same projection as above; access via slots
[1] &quot;+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0&quot;
</code></pre>

<p>Next, let&#39;&#39;s import a multi-band raster of Landsat 7 images, <strong>etm-038031-042600-123457.img</strong>.  The images are of type <strong>ESRI</strong> <strong>.img</strong> format.</p>

<pre><code class="r">## import raster from mulit-band landsat file; naive call
##   see package =&gt; landsat if truly serious about this, but for now ....
   landsat7 &lt;- raster(&quot;etm-038031-042600-123457.img&quot;)
## examine landsat7; NOTE &quot;band&quot; attribute w/values &quot;1 (of  6  bands)&quot;
##   defaulted to importing band=1; other 6 ignored
   landsat7
</code></pre>

<p>Because this is a multi-band image, the raster contains an additional characteristic, the <strong>band</strong>.  It states <em>1  (of  6  bands)</em>, indicating that the raster import defaults to only the first of the six available bands in the image.  All other characteristics are similar to the NDVI raster imported above.</p>

<pre><code>class       : RasterLayer 
band        : 1  (of  6  bands)
dimensions  : 7839, 8173, 64068147  (nrow, ncol, ncell)
resolution  : 30, 30  (x, y)
extent      : -1400595, -1155405, 2072565, 2307735  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs 
data source : E:\IALE2015_gisRcourse\data\etm-038031-042600-123457.img 
names       : etm.038031.042600.123457 
values      : 0, 255  (min, max)
</code></pre>

<p>Use the <strong>band =</strong> option to select particular bands during import.  You should, of course, have a basic understanding of the imagery you are importing and hence would know which bands represent what spectral characteristics.  </p>

<pre><code class="r">## build raster from multi-band file; select band of interest w/&quot;band=&quot; option
##   you must know band sequence, eg that band=6 represents landsat band 7
##   (PS this ex. does not have band 6)
   landsat7.1 &lt;- raster(&quot;etm-038031-042600-123457.img&quot;, band = 1)  # blue
   landsat7.2 &lt;- raster(&quot;etm-038031-042600-123457.img&quot;, band = 2)  # green
   landsat7.3 &lt;- raster(&quot;etm-038031-042600-123457.img&quot;, band = 3)  # red
   landsat7.1; landsat7.2  # examine
</code></pre>

<p>Notice that the <strong>band =</strong> option results in differen <strong>band</strong> values for each of the imported rasters.  here, 1 (top) is the blue band while 2 (the bottom) is the green band.</p>

<pre><code>class       : RasterLayer 
band        : 1  (of  6  bands)
dimensions  : 7839, 8173, 64068147  (nrow, ncol, ncell)
resolution  : 30, 30  (x, y)
extent      : -1400595, -1155405, 2072565, 2307735  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs 
data source : E:\IALE2015_gisRcourse\data\etm-038031-042600-123457.img 
names       : etm.038031.042600.123457 
values      : 0, 255  (min, max)

class       : RasterLayer 
band        : 2  (of  6  bands)
dimensions  : 7839, 8173, 64068147  (nrow, ncol, ncell)
resolution  : 30, 30  (x, y)
extent      : -1400595, -1155405, 2072565, 2307735  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs 
data source : E:\IALE2015_gisRcourse\data\etm-038031-042600-123457.img 
names       : etm.038031.042600.123457 
values      : 0, 255  (min, max)
</code></pre>

<p>It is recommended you change the names of the imported rasters to better reflect what each raster stands for.  here chnage the import image filename to <em>red</em>, which is what the tird band of Landsat 7 represents.</p>

<pre><code class="r">   names(landsat7.3) &lt;- &quot;red&quot;  # to assign name to band
   landsat7.3  # examine
</code></pre>

<hr/>

<h3>Summary</h3>

<hr/>

<p>Knowing the characteristics of spatial objects in R is an important first step in analysing spatial data in R.  You should get in the habit of always examining any imported spatial data object and examining its characteristics before starting analysis.</p>

<hr/>

<h2>END MODULE 2.1</h2>

</body>

</html>
