<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>MODULE 2.2</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: helvetica;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>MODULE 2.2</h1>

<hr/>

<h2>Objectives:</h2>

<h3>How to change (re-project) or assign a projection or resolution to vector-based data.</h3>

<hr/>

<hr/>

<h4>STUDENT WORKSHOP: USING R TO MODEL, MANIPULATE, AND MANAGE SPATIAL DATA</h4>

<h4>IALE 2015 World Congress, Portland, OR USA 7 July 2015</h4>

<blockquote>
<p>Karl Jarvis, Northern Arizona University</p>

<p>Whalen Dillon, North Carolina State University</p>

<p>Jill Deines, Michigan State University</p>

<p>Francesco Tonini, North Carolina State University</p>

<p>Thomas Edwards, U.S. Geological Survey and Utah State University</p>
</blockquote>

<h4>MODULE 2.2 CODE BY:</h4>

<blockquote>
<p>Thomas C. Edwards, U.S. Geological Survey and Department of Wildland Resources</p>

<p>Utah State University, Logan UT 84322-5230 USA <a href="mailto:t.edwards@usu.edu">t.edwards@usu.edu</a></p>

<p>(Tested on R versions 3.1.X, 3.2.X)</p>
</blockquote>

<hr/>

<hr/>

<h3>Let&#39;s begin.</h3>

<p>Start by loading some important libraries, &hellip;</p>

<pre><code class="r">## some libraries ...
   library(raster)    # fxns: raster, projectRaster, rasterize, brick, stack
   library(rgdal)     # fxns: readOGR, spTransform
   library(maptools)  # fxns: readShapePoly
</code></pre>

<p>&hellip; next set some paths for data access, &hellip;</p>

<pre><code class="r">## some initializations ...
   #path.root &lt;- &quot;~/IALE2015_gisRcourse&quot;
   #path.dat=&quot;E:/IALE2015_gisRcourse/data&quot;
   path.root &lt;- &quot;~/words/classes/IALE2015_gisRcourse&quot;
   path.dat &lt;- paste(path.root, &quot;/data&quot;, sep = &quot;&quot;)
   setwd(path.dat)
</code></pre>

<p>&hellip; determine some useful projections, &hellip;</p>

<pre><code class="r">## some projections as objects ...
## one source for projections:
##   http://spatialreference.org/ ; EXAMPLE access as shown in next line
##     Home =&gt; Search =&gt; EX: &quot;NAD83 Albers&quot; =&gt; Click &quot;AlbersNorthAmerican&quot; =&gt; Click &quot;Proj4js format&quot;
##     returns projection string; copy &amp; paste string, including quotes as below
## NOTE:  No hard returns allowed in projection string assignment; R won&#39;t like you
   prj.aea &lt;- &quot;+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0&quot;
   prj.wgs84 &lt;- &quot;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0&quot;
</code></pre>

<p>&hellip; and load some existing data layers we will use in this module.  </p>

<p>After loading, your workspace should include six new objects: <strong>base.rast</strong>, <strong>cp.poly</strong>, <strong>cp.rast</strong>, <strong>ext.buf</strong>, <strong>ext.fnet</strong>, and <strong>ext.rast</strong></p>

<pre><code class="r">## some input GIS layers &amp; characteristics from previous modules ...
   load(&quot;outdata/module1.RData&quot;)  # some shapefiles &amp; rasters from module #2.1
   ls()  # examine
</code></pre>

<pre><code> [1] &quot;base.rast&quot; &quot;cp.poly&quot;   &quot;cp.rast&quot;   &quot;ext.buf&quot;   &quot;ext.fnet&quot;  &quot;ext.rast&quot;  &quot;path.dat&quot;  &quot;path.root&quot; &quot;prj.aea&quot;   &quot;prj.wgs84&quot;
</code></pre>

<hr/>

<h3>Import a Shapefile and Assign Projection During Import</h3>

<hr/>

<p>Start by importing a shapefile of North American states, <strong>na_states_wgs.shp</strong>.  The <strong>readShapePoly()</strong> call (package <strong>maptools</strong>) is a naive call.  That is, no projection is assigned during import, and the <strong>coord. ref</strong> of <strong>states1</strong> is NA as a consequence.</p>

<pre><code class="r">## import a shapefile; fxn =&gt; readShapePOly
   states1 &lt;- readShapePoly(&quot;na_states_wgs&quot;)  # naive call
   states1  # examine; NOTE no projection (coord.ref); coordinates imply projection type
</code></pre>

<pre><code>class       : SpatialPolygonsDataFrame 
features    : 95 
extent      : -178.2199, -52.61911, 14.5515, 83.10936  (xmin, xmax, ymin, ymax)
coord. ref. : NA 
variables   : 2
names       : CODE,           NAME 
min values  :   AK, Aguascalientes 
max values  :   WY,      Zacatecas
</code></pre>

<p>Instead, assignment of a projection to the object <strong>states1</strong> must be made using the <strong>proj4string =</strong> option.  This assignment assumes you know the underlying projection of the shapefile being imported, which in this case is WGS84. (You can check this by looking at the shapefile&#39;&#39;s <strong>.prj</strong> file.)  The imported shapefile <strong>states2</strong> now has a proper <strong>coord. ref</strong>.</p>

<pre><code class="r">## import a shapefile &amp; assign projection during import
##   NOTE: fxn readShapePoly assumes you know projection 
   states2 &lt;- readShapePoly(&quot;na_states_wgs&quot;, proj4string = CRS(prj.wgs84))
   states2  # examine; NOTE projection (coord.ref) now assigned
</code></pre>

<pre><code>class       : SpatialPolygonsDataFrame 
features    : 95 
extent      : -178.2199, -52.61911, 14.5515, 83.10936  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0 
variables   : 2
names       : CODE,           NAME 
min values  :   AK, Aguascalientes 
max values  :   WY,      Zacatecas 
</code></pre>

<p><strong>A cautionary note</strong>.  You should <strong>NOT</strong> use the <strong>proj4string =</strong> option to attempt to change (as opposed to assign) the projection during import.  Below, the option was used to (try and) change the projection from WGS84 to Albers Equal Area (AEA).  Although the <strong>coord. ref.</strong> was changed to AEA, note that the extent is still in WGS84 lat-long.  This can, but not necessarily, create problems in the future.  We will see below a better way to change the spatial characteristics of a spatial object in R.</p>

<pre><code class="r">## import and change projection during import
   states3 &lt;- readShapePoly(&quot;na_states_wgs&quot;, proj4string = CRS(prj.aea))
   states3  # examine; NOTE change in projection (coord.ref)
</code></pre>

<pre><code>class       : SpatialPolygonsDataFrame 
features    : 95 
extent      : -178.2199, -52.61911, 14.5515, 83.10936  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0 
variables   : 2
names       : CODE,           NAME 
min values  :   AK, Aguascalientes 
max values  :   WY,      Zacatecas
</code></pre>

<p>Unlike <strong>readShapePOly()</strong>, <strong>readOGR()</strong> automatically assigns a projection based on the shapefile&#39;&#39;s associated <strong>.prj</strong> file.</p>

<pre><code class="r">## import a shapefile; fxn =&gt; readOGR
##   NOTE: dsn=&#39;.&#39; is cur dir, layer=&#39;shapefile to import&#39;
   states4 &lt;- readOGR(dsn = &quot;.&quot;, layer = &quot;na_states_wgs&quot;)  
   states4  # examine; NOTE readOGR automatically assigns projection (coord. ref)
</code></pre>

<pre><code>class       : SpatialPolygonsDataFrame 
features    : 95 
extent      : -178.2199, -52.61911, 14.5515, 83.10936  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 
variables   : 2
names       : CODE,           NAME 
min values  :   AK, Aguascalientes 
max values  :   WY,      Zacatecas 
</code></pre>

<hr/>

<h3>Change all Spatial Characteristics of a Polygon</h3>

<hr/>

<p>To properly change all aspects of the projection, use <strong>spTransform()</strong> (package <strong>rgdal</strong>) with the option <strong>CRS =</strong>.  The <strong>CRS =</strong> option is where the desired projection string, such as the objects <strong>prj.aea</strong> and <strong>prj.wgs84</strong> created above, is applied to the spatial polygon.  </p>

<p>As shown below, <strong>spTransform()</strong> not only assigned the desired AEA <strong>coord. ref.</strong> but also changed the <strong>extent</strong> to meters.</p>

<pre><code class="r">## change import projection (WGS84) to desired projection (AEA)
   states5 &lt;- spTransform(states4, CRS = CRS(prj.aea))
   states5  # examine; NOTE change in projection (ccord.ref)
</code></pre>

<pre><code>class       : SpatialPolygonsDataFrame 
features    : 95 
extent      : -6293579, 3189093, -893447.7, 6198912  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0 
variables   : 2
names       : CODE,           NAME 
min values  :   AK, Aguascalientes 
max values  :   WY,      Zacatecas 
</code></pre>

<hr/>

<h3>Import and Convert a Shapefile of Polygon Type to a Raster (Grid)</h3>

<hr/>

<p>Converting a polygon to a raster (grid) requires a so-called &ldquo;<em>base</em>&rdquo; raster.  This base raster must have a projection, extent, and resolution, characteristics which will be assigned to the polygon as it is converted to a raster.  The <strong>rasterize()</strong> call (package <strong>raster</strong>) is used to make the conversion of a polygon to a raster.</p>

<p>Assume a complex polygon with many attributes, as in <strong>soil.raw</strong> below.</p>

<pre><code class="r">##   assumes a &quot;base&quot; grid from elsewhere for raster conversion; here =&gt; ext.rast
   soil.raw &lt;- readOGR(dsn = &quot;.&quot;, layer = &quot;soils&quot;)  # be patient here ... ~3 min runtime
   soil.raw  # examine
</code></pre>

<pre><code>class       : SpatialPolygonsDataFrame 
features    : 6721 
extent      : -115.853, -104.678, 33.93571, 43.25238  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 
variables   : 44
names       :  mukey,  taxorder, taxsuborde,  taxgrtgrou,                        taxsubgrp, subord, grtgrp, c_order, c_sbord, c_ggrp, phmin, phave, phmax, frag3to10, sieveno4, ... 
min values  : 657964,  Alfisols,    Aquents, Aquicambids, Abruptic Argiduridic Durixerolls,    Aqu,    Aqu,     100,     100,    100,     0,     0,     0,         0,        0, ... 
max values  : 848685, Vertisols,    Xerolls, Xerorthents,             Xeric Torripsamments,    Xer,    Xer,     110,     127,    141,   840,   900,  1100,        48,      100, ... 
</code></pre>

<p>The rasterization process can be time-consuming.  Consequently you should choose which variables (attributes) you wish to rasterize, especially when the underlying polygon contains numerous variables, as is the case with the <strong>soil.raw</strong> polygon object.  There are 44 to choose from.  </p>

<p>Selection is best accomplished by calling the <strong>names()</strong> of the imported polygon (here, <strong>soil.raw</strong>) and then selecting which variable(s) you wish to rasterize.  </p>

<pre><code class="r">## examine names of attributes in the polygon
   names(soil.raw)  # attribute names to select from
</code></pre>

<pre><code> [1] &quot;mukey&quot;      &quot;taxorder&quot;   &quot;taxsuborde&quot; &quot;taxgrtgrou&quot; &quot;taxsubgrp&quot;  &quot;subord&quot;     &quot;grtgrp&quot;    
 [8] &quot;c_order&quot;    &quot;c_sbord&quot;    &quot;c_ggrp&quot;     &quot;phmin&quot;      &quot;phave&quot;      &quot;phmax&quot;      &quot;frag3to10&quot; 
[15] &quot;sieveno4&quot;   &quot;sieveno10&quot;  &quot;sieveno40&quot;  &quot;sieveno200&quot; &quot;sand&quot;       &quot;silt&quot;       &quot;clay&quot;      
[22] &quot;omr&quot;        &quot;dryweight&quot;  &quot;ksat&quot;       &quot;awc&quot;        &quot;wsat&quot;       &quot;minalogy&quot;   &quot;reaction&quot;  
[29] &quot;ph_ave&quot;     &quot;frag_3to10&quot; &quot;sieve_4&quot;    &quot;sieve_10&quot;   &quot;sieve_40&quot;   &quot;sieve_200&quot;  &quot;sand_txt&quot;  
[36] &quot;silt_txt&quot;   &quot;clay_txt&quot;   &quot;orgmat&quot;     &quot;dwieght&quot;    &quot;ksat_txt&quot;   &quot;awc_txt&quot;    &quot;wsat_txt&quot;  
[43] &quot;minerals&quot;   &quot;calcereous&quot;
</code></pre>

<p>Selection of the variable(s) to rasterize is accomplished using the <strong>field =</strong> option within the <strong>rasterize()</strong> call.  You can specify the the field by name, enclosing it within quotes (&ldquo;<em>Name2Rasterize</em>&rdquo;), or by column number.  <strong>rasterize()</strong> also requires a base raster, which is pre-determined raster of a dimension (ie number of rows, columns, cells), extent, projection, and resolution.  It may be convenient to consider the base raster as a &ldquo;<em>template</em>&rdquo; to which all polygons will be converted.</p>

<p>First select your base raster.  Here we use <strong>ext.rast</strong> as the base raster.  It&#39;&#39;s characteristics - a projection (<strong>coord. ref.</strong>), <strong>extent</strong>, and resolution (<strong>res</strong>) - serve as the template for converting the desired <strong>soil.raw</strong> variable polygons to rasters.</p>

<pre><code class="r">## examine the &quot;base&quot; raster
ext.rast   # examine
</code></pre>

<pre><code>class       : RasterLayer 
dimensions  : 638, 861, 549318  (nrow, ncol, ncell)
resolution  : 0.008333333, 0.008333333  (x, y)
extent      : -113.853, -106.678, 35.93571, 41.25238  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0 
data source : in memory
names       : layer 
values      : 1, 1  (min, max)
</code></pre>

<p>The example below uses <strong>ext.rast</strong> as the template, and using the <strong>field =</strong> option within the <strong>rasterize()</strong> call, converts the varaible <strong>phave</strong> polygon within <strong>soil.raw</strong> to a raster of the projection, extent, and resolution of the base raster <strong>ext.rast</strong>.  After conversion note that it&#39;&#39;s characteristics are identical to those of the base raster.</p>

<p>The rasterize process can be somewhat time-consuming, so be prepared.  The examples below take ~3-4 minutes runtime.</p>

<pre><code class="r">## rasterize 2 selected attributes to a given base raster =&gt; ext.rast
##   must select attribute to rasterize; use field=&quot;attribute name or column No.&quot; option
##   be patient here ... ~4-5 min runtimes
   cp.soil.1 &lt;- rasterize(soil.raw, field=&quot;phave&quot;, ext.rast)  # single variable selected
   #cp.soil.1 &lt;- rasterize(soil.raw, field=c(&quot;phave&quot;,&quot;awc&quot;), ext.rast)  # NOT RUN multiple variables selected
   names(cp.soil.1) &lt;- &quot;phave&quot;
   cp.soil.1  # examine
</code></pre>

<pre><code>class       : RasterLayer 
dimensions  : 638, 861, 549318  (nrow, ncol, ncell)
resolution  : 0.008333333, 0.008333333  (x, y)
extent      : -113.853, -106.678, 35.93571, 41.25238  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 
data source : in memory
names       : phave 
values      : 0, 900  (min, max)
</code></pre>

<p>Converting multiple polygons to rasters can be done by listing them sequentially in the <strong>field =</strong> option, such as <strong>field = c(&ldquo;phave&rdquo;,&ldquo;awc&rdquo;)</strong>.  </p>

<p>You can also build simple loop or function to perform the rasterization if you have many polygons you want to rasterize.  The process below - only one of many possible ways to accomplish this - starts by defining (<strong>soil.var</strong>) and then initializing (<strong>soil.list</strong>) a list of the variables to rasterize.  The guts of the loop is the same <strong>rasterize()</strong> call used above.  As each variables is rasterized it is added to the list.</p>

<pre><code class="r">## Create raster layer for each specified field
   soil.var &lt;- c(&quot;awc&quot;, &quot;phave&quot;)  # list of desired variables from shapefile polygon
   soil.list &lt;- list(length(soil.var))  # initialize blank list
## start loop; be patient ... can be time-consuming depending on CPU
##   NOTE ~5-6 min runtime for this example
for (i in 1:length(soil.var)) {
   ## status breadcrumbs ....
   print(&quot;##########&quot;);  print(&quot;Where the Hell am I in this process????&quot;);  print(date())
   print(paste(&quot;Step is&quot;, i, &quot;of&quot;, length(soil.var)));  print(paste(&quot;Soil is:&quot;, soil.var[i]))
   flush.console()
   ## create stand-alone objects for each soil var; will be in workspace at end of loop
   assign(paste(&quot;cp.&quot;, soil.var[i], sep = &quot;&quot;), 
          rasterize(soil.raw, ext.rast, field = soil.var[i]))
   ## add each created soil layer to soil list
   soil.list[[i]] &lt;- get(paste(&quot;cp.&quot;, soil.var[i], sep = &quot;&quot;))
   }
</code></pre>

<p>You now have a list of rasterized polygons, which can be subjected to further analyses or R operations, such as <strong>writeRaster()</strong> for export as, say, an ESRI <strong>.img</strong> format, or the <strong>save()</strong> call to save all objects as a <strong>.RData</strong> object.</p>

<pre><code class="r">## examine list of output raster &amp; rename
   soil.list  # examine; NOTE is a list of rasters
   names(soil.list) &lt;- soil.var  # assign names to the list objects
</code></pre>

<hr/>

<h3>END MODULE 2.2</h3>

</body>

</html>
